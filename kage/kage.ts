import { Buhin } from "./buhin.ts";
import { STROKETYPE } from "../stroketype.ts";
import { getBoundingBox, stretch } from "../util.ts";
import { Path } from "../curve/path.ts";
import { Font } from "../font.ts";

export class Kage {
  kBuhin: Buhin;
  kRate: number;
  kFont: Font;

  /**
   * Initializes the Kage object.
   */
  constructor() {
    this.kBuhin = new Buhin();
    this.kRate = 100;
  }

  /**
   * Given a character or composition sequence (e.g. ) return the generated SVG.
   */
  char2SVG(str: string): string {
    let ids = Kage.str2IDS(str);
    let paths = this.IDS2Paths(ids);
    return this.generateSVG(paths);
  }

  /**
   * Retrieves the KAGE stroke data given the character IDS string.
   */
  IDS2Paths(ids: string): Path[] {
    let glyphData = this.kBuhin.search(ids);

    if (glyphData === "") {
      glyphData = this.generateGlyphData(ids);
      this.kBuhin.set(ids, glyphData);
    }
    let kageStrokes = this.getStrokes(glyphData);

    return this.kFont.getPaths(kageStrokes);
  }

  /**
   * Takes an array of Path objects generated by kFont and returns an SVG.
   */
  generateSVG(paths: Path[]): string {
    return this.kFont.generateSVG(paths);
  }

  getStrokes(glyphData: string): number[][] {
    var strokes = new Array();
    var textData = glyphData.split("$");
    for (let i = 0; i < textData.length; i++) {
      var columns_str = textData[i].split(":");
      var columns: number[];
      for (let j = 0; j < columns_str.length; j++)
        columns.push(Number(columns_str));

      if (Math.floor(columns[0]) != STROKETYPE.REFERENCE) {
        strokes.push([
          Math.floor(columns[0]),
          Math.floor(columns[1]),
          Math.floor(columns[2]),
          Math.floor(columns[3]),
          Math.floor(columns[4]),
          Math.floor(columns[5]),
          Math.floor(columns[6]),
          Math.floor(columns[7]),
          Math.floor(columns[8]),
          Math.floor(columns[9]),
          Math.floor(columns[10])
        ]);

      } else {
        var buhin = this.kBuhin.search(columns[7].toString());
        if (buhin != "") {
          strokes = strokes.concat(this.getStrokesOfBuhin(buhin,
            Math.floor(columns[3]),
            Math.floor(columns[4]),
            Math.floor(columns[5]),
            Math.floor(columns[6]),
            Math.floor(columns[1]),
            Math.floor(columns[2]),
            Math.floor(columns[9]),
            Math.floor(columns[10]))
          );
        }
      }
    }

    return strokes;
  }

  getStrokesOfBuhin(buhin: string, x1, y1, x2, y2, sx, sy, sx2, sy2): number[][] {
    var temp = this.getStrokes(buhin);
    var result = new Array();
    var box = getBoundingBox(temp);

    if (sx != 0 || sy != 0) {
      if (sx > 100) {
        sx -= 200;
      } else {
        sx2 = 0;
        sy2 = 0;
      }
    }

    for (var i = 0; i < temp.length; i++) {
      if (sx != 0 || sy != 0) {
        temp[i][3] = stretch(sx, sx2, temp[i][3], box.minX, box.maxX);
        temp[i][4] = stretch(sy, sy2, temp[i][4], box.minY, box.maxY);
        temp[i][5] = stretch(sx, sx2, temp[i][5], box.minX, box.maxX);
        temp[i][6] = stretch(sy, sy2, temp[i][6], box.minY, box.maxY);

        if (temp[i][0] != STROKETYPE.REFERENCE) {
          temp[i][7] = stretch(sx, sx2, temp[i][7], box.minX, box.maxX);
          temp[i][8] = stretch(sy, sy2, temp[i][8], box.minY, box.maxY);
          temp[i][9] = stretch(sx, sx2, temp[i][9], box.minX, box.maxX);
          temp[i][10] = stretch(sy, sy2, temp[i][10], box.minY, box.maxY);
        }
      }

      result.push([temp[i][0],
        temp[i][1],
        temp[i][2],
        x1 + temp[i][3] * (x2 - x1) / 200,
        y1 + temp[i][4] * (y2 - y1) / 200,
        x1 + temp[i][5] * (x2 - x1) / 200,
        y1 + temp[i][6] * (y2 - y1) / 200,
        x1 + temp[i][7] * (x2 - x1) / 200,
        y1 + temp[i][8] * (y2 - y1) / 200,
        x1 + temp[i][9] * (x2 - x1) / 200,
        y1 + temp[i][10] * (y2 - y1) / 200]);

    }

    return result;
  }

  //for compatibility
  /*
  getEachStrokes(glyphData: string): number[][] {
    const ss = this.getStrokes(glyphData);
    ss.map(s=>{
      s.a1_opt = Math.floor(s[0] / 100);
      s.a1_100 = s[0]%100;

      s.a2_opt = Math.floor(s[1] / 100);
      s.a2_100 = s[1]%100;
      s.a2_opt_1 = s.a2_opt % 10;
      s.a2_opt_2 = Math.floor(s.a2_opt / 10) % 10;
      s.a2_opt_3 = Math.floor(s.a2_opt / 100);

      s.a3_opt = Math.floor(s[2] / 100);
      s.a3_100 = s[2]%100;
      s.a3_opt_1 = s.a3_opt % 10;
      s.a3_opt_2 = Math.floor(s.a3_opt / 10);

      s.x1=s[3];
      s.y1=s[4];
      s.x2=s[5];
      s.y2=s[6];
      s.x3=s[7];
      s.y3=s[8];
      s.x4=s[9];
      s.y4=s[10];
    })

    return ss;
  }
  */

  getBox(strokes) {
    return getBoundingBox(strokes);
  }

  stretch(dp, sp, p, min, max) {
    return stretch(dp, sp, p, min, max);
  }

  /**
   * Convert a string input (e.g. "⿰女子") into the IDS format. This function
   * should not take in nested compositions like "⿰糹⿱土口".
   */
  static str2IDS(input: string): string {
    var result = new Array();

    for(let i = 0; i < input.length; i++) {
      var unicode: string;

      if(input.charCodeAt(i) < 0xd800 || input.charCodeAt(i) > 0xdfff) {
        unicode = input.charCodeAt(i).toString(16).toLowerCase();
        unicode = "u" + ("000" + unicode).substring(unicode.length - 1, unicode.length - 1 + 4);
      } else {
        unicode = ((input.charCodeAt(i) - 0xd800) * 0x0400 +
                   input.charCodeAt(i + 1) - 0xdc00 + 0x10000).toString(16).toLowerCase();
        unicode = "u" + unicode;
        i++;
      }

      result.push(unicode);
    }

    return result.join("-");
  }

  /**
   * Takes the ids of a single character and decomposes it, for example:
   * u597d -> u2ff0-u5973-u5b50
   * (好 -> ⿰女子)
   */
  decomposeCharIDS(ids: string): string {
    /* TODO */
  }

  /**
   * Given an IDS string, generate the KAGE glyph data with adjusted
   * proportions.
   */
  generateGlyphData(ids: string): string {
    let components = ids.split("-");

    // Ensure all dependencies are generated.
    for (let i = 1; i < components.length; i++) {
      if (this.kBuhin.search(components[i]) === "") {
        let decomposed = this.decomposeCharIDS(components[i]);
        this.kBuhin.set(components[i], this.generateGlyphData(decomposed));
      }
    }

    /* TODO: Take dependency components and adjust them. */
  }
}
